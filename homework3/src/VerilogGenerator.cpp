#include "VerilogGenerator.h"
#include <fstream>
#include <sstream>
#include <algorithm> // For std::remove_if
#include <cctype> // For std::isspace
#include <chrono>
#include <ctime>
#include <iostream>
#include <cmath>

std::string decimalToBinary(int decimal, int bitWidth) {
    std::string binary = "";
    while (decimal > 0) {
        int remainder = decimal % 2;
        binary = std::to_string(remainder) + binary;
        decimal /= 2;
    }

    int missingBits = bitWidth - binary.length();
    if (missingBits > 0) {
        binary = std::string(missingBits, '0') + binary;
    }

    return binary;
}

VerilogGenerator::VerilogGenerator(const std::vector<Component>& components, const std::vector<Operation>& operations, Graph* graph)
    : components(components), operations(operations), graph(graph) {}

void VerilogGenerator::generateVerilog(const std::string& outputPath, const std::string& moduleName) {
    std::ofstream outFile(outputPath);
    std::stringstream moduleDecl, declarations;
    auto now = std::chrono::system_clock::now();
    std::time_t currentTime = std::chrono::system_clock::to_time_t(now);
    std::string widthSpecifier;

    // Write system log info
    moduleDecl << "// Generated by University of Arizona - ECE 574 - HLS Tool\n"
            << "// Authors: Mustafa Ghanim and Umut Suluhan\n"
            << "// Date and Time: " << std::ctime(&currentTime)  << "\n"; // ctime includes a newline at the end
    // Start module declaration
    moduleDecl <<"`timescale 1ns / 1ps\n" << "module " << moduleName << "(\n";
    moduleDecl << "\tinput Clk, Rst, Start,\n"; 
    moduleDecl << "\toutput reg Done,\n"; 

    // Process components to generate module IOs and wires
    for (const auto& component : components) {
        std::string signModifier = component.isSigned ? " signed" : "";
        widthSpecifier = (component.width > 1) ? " [" + std::to_string(component.width - 1) + ":0]" : "";
        
        if (component.type == "input") {
            moduleDecl << "\tinput" << signModifier << widthSpecifier << " " << component.name << ",\n";
        } else if (component.type == "output") {
            moduleDecl << "\toutput reg" << signModifier << widthSpecifier << " " << component.name << ",\n";
        } else if (component.type == "variable") {
            declarations << "\treg" << signModifier << widthSpecifier << " " << component.name << ";\n";
        }
        // else if (component.type == "wire" || component.type == "register") {
        //     declarations << "wire" << signModifier << widthSpecifier << " " << component.name << ";\n";
        // }
    }

    std::vector<int64_t>scheduled_times;
    int64_t state_counter = 0;
    for(const auto& vertex : this->graph->vertices){
        auto it = std::find(scheduled_times.begin(), scheduled_times.end(), vertex->fds_time + 1);
        if (it == scheduled_times.end()) {
            scheduled_times.push_back(vertex->fds_time + 1);
        }
        if (vertex->fds_time > state_counter){
            state_counter = vertex->fds_time;
        }
    }
    std::sort(scheduled_times.begin(), scheduled_times.end());
    state_counter += 3;
    
    for(const auto& vertex : this->graph->vertices){
        if(vertex->next.size() == 0){
            if(state_counter + (vertex->latency - 1) > state_counter){
                state_counter = state_counter + (vertex->latency - 1);
            }
        }
    }
    
    int64_t state_width = std::ceil(std::log2(state_counter));

#if defined(ENABLE_LOGGING)  
    std::cout << "Number of states:" << state_counter << std::endl;
    std::cout << "Width of state register:" << state_width << std::endl;
#endif

    widthSpecifier = (state_width > 1) ? " [" + std::to_string(state_width - 1) + ":0]" : "";
    declarations << "\n\treg" << widthSpecifier << " state" << ";\n";

    std::string binary_state; 
    binary_state = decimalToBinary(0, state_width);
    declarations << "\n\tlocalparam Wait = " << state_width << "'b"<< binary_state << ";\n";
    binary_state = decimalToBinary(state_counter - 1, state_width);
    declarations << "\tlocalparam Final = " << state_width << "'b"<< binary_state << ";\n";

    // Remove the last comma and add closing parenthesis
    std::string moduleDeclStr = moduleDecl.str();
    moduleDeclStr = moduleDeclStr.substr(0, moduleDeclStr.rfind(',')) + "\n);";
    
    outFile << moduleDeclStr << "\n" << declarations.str() << "\n";

    std::stringstream sequential = this->generateSequentialCode(state_counter - 1);

    outFile << sequential.str() << "\n";

    outFile << "endmodule\n";

}
// version 0

/*
std::stringstream VerilogGenerator::generateSequentialCode(int64_t state_counter) {
    std::stringstream sequential;

    sequential << "\talways @(posedge Clk) begin\n";
    sequential << "\t\tif (Rst) begin\n";
    sequential << "\t\t\tstate <= Wait;\n";

    for (const auto& component : components) {
        if (component.type == "output" || component.type == "variable") {
            sequential << "\t\t\t" << component.name << " <= 0;\n";
        }
    }
    sequential << "\t\tend\n";
    
    sequential << "\t\telse begin\n";

    sequential << "\t\t\tcase (state)\n";

    sequential << "\t\t\t\tWait: begin\n";
    sequential << "\t\t\t\t\tif (Start == 1) begin\n";
    sequential << "\t\t\t\t\t\tstate <= 1;\n";
    sequential << "\t\t\t\t\tend\n";
    sequential << "\t\t\t\t\telse begin\n";
    sequential << "\t\t\t\t\t\tstate <= Wait;\n";
    sequential << "\t\t\t\t\tend\n";
    sequential << "\t\t\t\tend\n";

    for(int state = 1; state < state_counter; state++){
        sequential << "\t\t\t\t" << state << ": begin\n";
        bool if_open = false;  // Flag to keep track of whether an 'if' block is open
        bool jump_ext_state = false;
        bool else_flag = false;
        for (const auto& vertex : this->graph->vertices) {
            if (vertex->fds_time == state - 1) {
                if (if_open && vertex->operation.opType != "IF") {
                    sequential << "\t\t\t\t\t\t\tstate <= " << state + 1 << ";\n";
                    sequential << "\t\t\t\t\t\tend\n";  // Close the previous 'if' block
                    jump_ext_state = true;
                    if_open = false;  // Reset the flag as the 'if' block is now closed
                }

                if (vertex->operation.opType != "IF") {
                    if(vertex->operation.condition != ""){
                         if(vertex->operation.enter_branch)
                            sequential << "\t\t\t\t\t\t" << "if (" << vertex->operation.condition <<") begin"  << "\n";
                         else sequential << "\t\t\t\t\t\t" << "if (!" << vertex->operation.condition <<") begin"  << "\n";
                         sequential << "\t\t\t\t\t\t\t" << vertex->operation.line  << "\n";
                         sequential << "\t\t\t\t\t\t" << "end"  << "\n";


                    }
                    else
                        sequential << "\t\t\t\t\t\t" << vertex->operation.line << "\n";
                    
                } else {
                    if (if_open) { // Close the current 'if' before opening a new one
                        sequential << "\t\t\t\t\t\t\tstate <= " << state + 1 << ";\n";
                        jump_ext_state = true;
                        sequential << "\t\t\t\t\t\tend\n";
                    }
                    sequential << "\t\t\t\t\t\t" << vertex->operation.line << " begin\n";
                    if_open = true;  // Set the flag as an 'if' block has been opened
                }
            }
        }

        // Close any open 'if' block at the end of the state
        if (if_open) {
            sequential << "\t\t\t\t\t\t\tstate <= " << state + 1 << ";\n";
            sequential << "\t\t\t\t\t\tend\n";
            if_open = false;
            jump_ext_state = true;
        }

        // Define state transition for non-final states
        if (state == state_counter - 1) {
            sequential << "\t\t\t\t\t\tstate <= Final;\n"; // Transition to final state
        } else {
            for (const auto& vertex : this->graph->vertices) {
                if(vertex->operation.isBranch && !vertex->operation.enter_branch) {
                    jump_ext_state = false;
                    break;
                }

            }   
            if(jump_ext_state)
                sequential << "\t\t\t\t\t\tstate <= " << state + 2 << ";\n"; // Proceed to the next state
            else sequential << "\t\t\t\t\t\tstate <= " << state + 1 << ";\n"; // Proceed to the next state     
        }
        sequential << "\t\t\t\tend\n";


    }

    sequential << "\t\t\t\tFinal: begin\n";
    sequential << "\t\t\t\t\tDone <= 1;\n";
    sequential << "\t\t\t\t\tstate <= Wait;\n";
    sequential << "\t\t\t\tend\n";


    sequential << "\t\t\tendcase\n";

    sequential << "\t\tend\n";


    sequential << "\tend\n";

    return sequential;
    
}
*/
// version 1


std::stringstream VerilogGenerator::generateSequentialCode(int64_t state_counter) {
    std::stringstream sequential;

    sequential << "\talways @(posedge Clk) begin\n";
    sequential << "\t\tif (Rst) begin\n";
    sequential << "\t\t\tstate <= Wait;\n";

    for (const auto& component : components) {
        if (component.type == "output" || component.type == "variable") {
            sequential << "\t\t\t" << component.name << " <= 0;\n";
        }
    }
    sequential << "\t\tend\n";
    
    sequential << "\t\telse begin\n";

    sequential << "\t\t\tcase (state)\n";

    sequential << "\t\t\t\tWait: begin\n";
    sequential << "\t\t\t\t\tif (Start == 1) begin\n";
    sequential << "\t\t\t\t\t\tstate <= 1;\n";
    sequential << "\t\t\t\t\tend\n";
    sequential << "\t\t\t\t\telse begin\n";
    sequential << "\t\t\t\t\t\tstate <= Wait;\n";
    sequential << "\t\t\t\t\tend\n";
    sequential << "\t\t\t\tend\n";
    for(int state = 1; state < state_counter; state++){
        sequential << "\t\t\t\t" << state << ": begin\n";
        for (const auto& vertex : this->graph->vertices) {
            std::string nested_condition;
            if (vertex->fds_time == state - 1) {
                if(vertex->operation.condition != ""){
                     Node *tmp_vertex = vertex;
                    std::set<std::string> visited; // To track visited nodes and prevent cycles
                    for (int i = 0; i <  this->graph->vertices.size(); i++) {
                        bool found = false; // Flag to check if we should break the outer loop

                        for (const auto& Othervertex : this->graph->vertices) {
                            // Ensure we're looking at a different vertex that matches the needed condition
                            if (tmp_vertex->operation.name != Othervertex->operation.name &&
                                Othervertex->operation.opType == "IF" &&
                                !tmp_vertex->operation.condition.empty() &&
                                tmp_vertex->operation.condition == Othervertex->operation.result) {

                                // Prevent cycles by checking if we've already visited this node
                                if (visited.find(Othervertex->operation.name) != visited.end()) {
                                    #if defined(ENABLE_LOGGING)  
                                    std::cout << "Cycle detected, stopping traversal." << std::endl;
                                    #endif 
                                    break; // Break inner loop to stop processing further
                                }

                                // Append condition based on the branch type
                                if (Othervertex->operation.enter_branch && Othervertex->operation.condition!="") {
                                    nested_condition += " && " + Othervertex->operation.condition;
                                } else if (!Othervertex->operation.enter_branch && Othervertex->operation.condition!="") {
                                    nested_condition += " && !" + Othervertex->operation.condition;
                                }

                                // Move to the next vertex and mark the current one as visited
                                visited.insert(tmp_vertex->operation.name);
                                tmp_vertex = Othervertex;
                                found = true; // Mark that we have found a next vertex
                                break; // Break inner loop since we are changing the tmp_vertex
                            }
                        }

                        // If no valid next vertex was found, break the outer loop
                        if (!found) {
                            break;
                        }
                    }
                }                   
                /*if(vertex->operation.opType == "IF"){
                    sequential << "\t\t\t\t\t\t" << "// This state includes a 1-cycle scheduled IF node where the state transition represents its latency." << "\n";
                }*/    
                if(vertex->operation.opType != "IF"){
                    if(vertex->operation.condition != ""){
 



                        
                        if(vertex->operation.enter_branch){
                            
                            sequential << "\t\t\t\t\t\t" << "if (" << vertex->operation.condition + nested_condition <<") begin"  << "\n";
                        }
                        else {
                            sequential << "\t\t\t\t\t\t" << "if (!" << vertex->operation.condition + nested_condition <<") begin"  << "\n";
                        }    
                        sequential << "\t\t\t\t\t\t\t" << vertex->operation.line  << "\n";
                        sequential << "\t\t\t\t\t\t" << "end"  << "\n";


                    }
                    else
                        sequential << "\t\t\t\t\t\t" << vertex->operation.line << "\n";
                    
                } 

            }
        }



        // Define state transition for non-final states
        if (state == state_counter - 1) {
            sequential << "\t\t\t\t\t\tstate <= Final;\n"; // Transition to final state
        } else {
            
            sequential << "\t\t\t\t\t\tstate <= " << state + 1 << ";\n"; // Proceed to the next state     
        }
        sequential << "\t\t\t\tend\n";


    }

    sequential << "\t\t\t\tFinal: begin\n";
    sequential << "\t\t\t\t\tDone <= 1;\n";
    sequential << "\t\t\t\t\tstate <= Wait;\n";
    sequential << "\t\t\t\tend\n";


    sequential << "\t\t\tendcase\n";

    sequential << "\t\tend\n";


    sequential << "\tend\n";

    return sequential;
    
}
