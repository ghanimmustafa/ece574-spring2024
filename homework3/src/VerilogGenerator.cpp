#include "VerilogGenerator.h"
#include <fstream>
#include <sstream>
#include <algorithm> // For std::remove_if
#include <cctype> // For std::isspace
#include <chrono>
#include <ctime>
#include <iostream>
#include <cmath>

std::string decimalToBinary(int decimal, int bitWidth) {
    std::string binary = "";
    while (decimal > 0) {
        int remainder = decimal % 2;
        binary = std::to_string(remainder) + binary;
        decimal /= 2;
    }

    int missingBits = bitWidth - binary.length();
    if (missingBits > 0) {
        binary = std::string(missingBits, '0') + binary;
    }

    return binary;
}

VerilogGenerator::VerilogGenerator(const std::vector<Component>& components, const std::vector<Operation>& operations, Graph* graph)
    : components(components), operations(operations), graph(graph) {}

void VerilogGenerator::generateVerilog(const std::string& outputPath, const std::string& moduleName) {
    std::ofstream outFile(outputPath);
    std::stringstream moduleDecl, declarations;
    auto now = std::chrono::system_clock::now();
    std::time_t currentTime = std::chrono::system_clock::to_time_t(now);
    std::string widthSpecifier;

    // Write system log info
    moduleDecl << "// Generated by University of Arizona - ECE 574 - HLS Tool\n"
            << "// Authors: Mustafa Ghanim and Umut Suluhan\n"
            << "// Date and Time: " << std::ctime(&currentTime)  << "\n"; // ctime includes a newline at the end
    // Start module declaration
    moduleDecl <<"`timescale 1ns / 1ps\n" << "module " << moduleName << "(\n";
    moduleDecl << "\tinput Clk, Rst, Start,\n"; 
    moduleDecl << "\toutput reg Done,\n"; 

    // Process components to generate module IOs and wires
    for (const auto& component : components) {
        std::string signModifier = component.isSigned ? " signed" : "";
        widthSpecifier = (component.width > 1) ? " [" + std::to_string(component.width - 1) + ":0]" : "";
        
        if (component.type == "input") {
            moduleDecl << "\tinput" << signModifier << widthSpecifier << " " << component.name << ",\n";
        } else if (component.type == "output") {
            moduleDecl << "\toutput" << signModifier << widthSpecifier << " " << component.name << ",\n";
        } else if (component.type == "variable") {
            declarations << "\treg" << signModifier << widthSpecifier << " " << component.name << ";\n";
        }
        // else if (component.type == "wire" || component.type == "register") {
        //     declarations << "wire" << signModifier << widthSpecifier << " " << component.name << ";\n";
        // }
    }

    std::vector<int64_t>scheduled_times;
    int64_t state_counter = 0;
    for(const auto& vertex : this->graph->vertices){
        auto it = std::find(scheduled_times.begin(), scheduled_times.end(), vertex->fds_time + 1);
        if (it == scheduled_times.end()) {
            scheduled_times.push_back(vertex->fds_time + 1);
        }
        if (vertex->fds_time > state_counter){
            state_counter = vertex->fds_time;
        }
    }
    std::sort(scheduled_times.begin(), scheduled_times.end());
    state_counter += 3;
    int64_t state_width = std::ceil(std::log2(state_counter));

#if defined(ENABLE_LOGGING)  
    std::cout << "Number of states:" << state_counter << std::endl;
    std::cout << "Width of state register:" << state_width << std::endl;
#endif

    widthSpecifier = (state_width > 1) ? " [" + std::to_string(state_width - 1) + ":0]" : "";
    declarations << "\n\treg" << widthSpecifier << " state" << ";\n";

    std::string binary_state; 
    binary_state = decimalToBinary(0, state_width);
    declarations << "\n\tlocalparam Wait = " << state_width << "'b"<< binary_state << ";\n";
    binary_state = decimalToBinary(state_counter - 1, state_width);
    declarations << "\tlocalparam Final = " << state_width << "'b"<< binary_state << ";\n";

    // Remove the last comma and add closing parenthesis
    std::string moduleDeclStr = moduleDecl.str();
    moduleDeclStr = moduleDeclStr.substr(0, moduleDeclStr.rfind(',')) + "\n);";
    
    outFile << moduleDeclStr << "\n" << declarations.str() << "\n";

    // Generate and write code for each operation
    // for (const auto& operation : operations) {
    //     outFile << generateOperationCode(operation) << std::endl;
    // }

    std::stringstream sequential = this->generateSequentialCode(scheduled_times);

    outFile << sequential.str() << "\n";

    outFile << "endmodule\n";

}

std::stringstream VerilogGenerator::generateSequentialCode(std::vector<int64_t>scheduled_times) {
    std::stringstream sequential;

    sequential << "\talways @(posedge clk) begin\n";
    sequential << "\t\tif (rst) begin\n";
    sequential << "\t\t\tstate <= Wait;\n";

    for (const auto& component : components) {
        if (component.type == "output" || component.type == "variable") {
            sequential << "\t\t\t" << component.name << " = 0;\n";
        }
    }
    sequential << "\t\tend\n";
    
    sequential << "\t\telse begin\n";

    sequential << "\t\t\tcase (state)\n";

    sequential << "\t\t\t\tWait: begin\n";
    sequential << "\t\t\t\t\tif (Start == 1) begin\n";
    sequential << "\t\t\t\t\t\tState <= 1;\n";
    sequential << "\t\t\t\t\tend\n";
    sequential << "\t\t\t\t\telse begin\n";
    sequential << "\t\t\t\t\t\tState <= Wait;\n";
    sequential << "\t\t\t\t\tend\n";
    sequential << "\t\t\t\tend\n";

    for(int iter = 0; iter < scheduled_times.size(); iter++){
        int64_t state = scheduled_times.at(iter);
        sequential << "\t\t\t\t" << state << ": begin\n";
        for(const auto& vertex : this->graph->vertices){
            if(vertex->fds_time == state - 1){
                sequential << "\t\t\t\t\t\t" << vertex->operation.line << "\n";
            }
        }
        if(state == scheduled_times.at(scheduled_times.size() - 1)){
            sequential << "\t\t\t\t\t\tstate <= Final;\n";
        }else{
            int64_t next_state = iter + 1;
            sequential << "\t\t\t\t\t\tstate <= " << scheduled_times.at(next_state) <<";\n";
        }
        sequential << "\t\t\t\tend\n";
    }

    sequential << "\t\t\t\tFinal: begin\n";
    sequential << "\t\t\t\t\tDone <= 1;\n";
    sequential << "\t\t\t\t\tState <= Wait;\n";
    sequential << "\t\t\t\tend\n";


    sequential << "\t\t\tendcase\n";

    sequential << "\t\tend\n";


    sequential << "\tend\n";

    return sequential;
    
}

std::string VerilogGenerator::generateOperationCode(const Operation& operation) const {
    std::stringstream ss;
    static std::unordered_map<std::string, int> opCounters;
    int count = ++opCounters[operation.opType];
    std::string moduleName = operation.isSigned ? "S" + operation.opType : operation.opType;
    // Function to determine the required padding or extension for operands
    auto bit_extensions = [&](const std::string& operand) {
        for (const auto& comp : components) {
            if (comp.name == operand) {
                // Check if the operand is signed
                bool isSignedOperand = comp.isSigned;
                bool isSignedOperation = operation.isSigned;
                // Get the width of the operand
                int operandWidth = comp.width;
                // Determine the required padding or extension
                int requiredWidth = operation.width; // Width of the result
                if (operation.opType == "MUX2x1" && operand == operation.operands[0] && operandWidth >= 1) {
                // For MUX2x1 operation, modify the third operand to take only its LSB
                    if(operandWidth > 1 ) return operand + "[0]";
                    else  return operand;
                  
                }               
                if (operandWidth < requiredWidth) {
                    if (isSignedOperand) {
                        // Sign extension
                        return "{{" + std::to_string(requiredWidth - operandWidth) + "{" + operand + "[" + std::to_string(operandWidth - 1) + "]}}, " + operand + "}";
                    } else {
                        // Zero padding
                        return "{{" + std::to_string(requiredWidth - operandWidth) + "{1'b0}}, " + operand + "}";
                    }
                } else if (operandWidth > requiredWidth) {
                    // Extract least significant bits if operand width is greater
                    return operand + "[" + std::to_string(requiredWidth - 1) + ":0]";
                }
            }
        }
        // Return original operand if not found in components
        return operand;
    };
    auto bit_extension_and_sign_check = [&](const std::string& operand,int index) {
        std::string extended_operand = operand;
        for (const auto& comp : components) {
            if (comp.name == operand) {
                // Check if the operand is signed
                bool isSignedOperand = comp.isSigned;
                // Check if the operation is signed
                bool isSignedOperation = operation.isSigned;

                // Determine the required padding or extension
                int operandWidth = comp.width;
                int requiredWidth = operation.width; // Width of the result

                // Perform bit extension or truncation
                if (operandWidth < requiredWidth) {
                    if (isSignedOperand) {
                        // Sign extension
                        extended_operand = "{{" + std::to_string(requiredWidth - operandWidth) + "{" + operand + "[" + std::to_string(operandWidth - 1) + "]}}, " + operand + "}";
                    } else {
                        // Zero padding
                        extended_operand = "{{" + std::to_string(requiredWidth - operandWidth) + "{1'b0}}, " + operand + "}";
                    }
                } else if (operandWidth > requiredWidth) {
                    // Extract least significant bits if operand width is greater
                    extended_operand += "[" + std::to_string(requiredWidth - 1) + ":0]";
                }

                // Handle sign conversion
                if (isSignedOperand != isSignedOperation) {
                    // Debug: Print component and operation information
                    #if defined(ENABLE_LOGGING)  
                    std::cout << "Debug: Component found: " << comp.name << ", isSigned: " << (comp.isSigned ? "true" : "false") << ", width: " << comp.width << std::endl;
                    std::cout << "Debug: Operation sign: " << (isSignedOperation ? "signed" : "unsigned") << ", width: " << operation.width << std::endl;
                    #endif 
                    // Operand sign and operation sign are different
                    if (isSignedOperation) {
                        // Add $signed(operand)
                        if((operation.opType != "SHR" || operation.opType != "SHL") && index !=2)
                            extended_operand = "$signed(" + extended_operand + ")";
                    } else {
                        // Add $unsigned(operand)
                        extended_operand = "$unsigned(" + extended_operand + ")";
                    }
                }

                // For MUX2x1 operation, modify the third operand to take only its LSB
                if (operation.opType == "MUX2x1" && operand == operation.operands[0] && operandWidth >= 1) {
                    if (operandWidth > 1) {
                        extended_operand = operand + "[0]";
                    }
                    else if (operandWidth == 1) {
                        extended_operand = operand;
                    }
                }

                return extended_operand;
            }
        }

        // Return original operand if not found in components
        return operand;
    };




    auto operand_sign_check = [&](const std::string& operand) {
        for (const auto& comp : components) {
            if (comp.name == operand) {
                // Check if the operand is signed
                bool isSignedOperand = comp.isSigned;
                // Check if the operation is signed
                bool isSignedOperation = operation.isSigned;
                
                if (isSignedOperand != isSignedOperation) {
                    // Operand sign and operation sign are different
                    if (isSignedOperation) {
                        // Add $signed(operand)
                        return "$signed(" + operand + ")";
                    } else {
                        // Add $unsigned(operand)
                        return "$unsigned(" + operand + ")";
                    }
                } else {
                    // Operand sign matches operation sign
                    return operand;
                }
            }
        }
        // Return original operand if not found in components
        return operand;
    };   
    std::string first_operand, second_operand, third_operand;
     // In-place modification of operands
    // Modify operands based on availability
    int index;
    if (operation.operands.size() > 0) {        
        index = 1;
        first_operand = bit_extension_and_sign_check(operation.operands[0],index);

    }
    if (operation.operands.size() > 1) {
        index = 2;
        second_operand = bit_extension_and_sign_check(operation.operands[1],index);

    }
    if (operation.operands.size() > 2) {
        index = 3;
        third_operand = bit_extension_and_sign_check(operation.operands[2],index);
    }
   // std::string second_operand = getModifiedOperand(operation.operands[1]);
    // Choose the submodule name based on signedness
  // Preprocess operands
    if (operation.opType == "REG") { // Assuming "+" denotes ADD operation
        // Example instantiation of an ADD datapath component
        ss << "REG" << " # (.DATAWIDTH("<< operation.width <<")) " << operation.opType << "_" << count <<
             " (.d("<< first_operand<<"),.Clk(Clk),.Rst(Rst),.q("<< operation.result <<"));";
    }    
    if (operation.opType == "ADD") { // Assuming "+" denotes ADD operation
        // Example instantiation of an ADD datapath component
        ss << operation.result << " = " << first_operand << " + " << second_operand << "\n;";
        // ss << moduleName << " # (.DATAWIDTH("<< operation.width <<")) " << operation.opType << "_" << count <<
        //      " (.a("<< first_operand <<"),.b(" << second_operand
        //    <<"),.sum("<< operation.result <<"));";
    }
    else if (operation.opType == "SUB") { 
        ss << moduleName << " # (.DATAWIDTH("<< operation.width <<")) " << operation.opType << "_" << count <<
             " (.a("<< first_operand<<"),.b(" << second_operand
           <<"),.diff("<< operation.result <<"));";
    }

    else if (operation.opType == "MUL") { 
        ss << moduleName << " # (.DATAWIDTH("<< operation.width <<")) " << operation.opType << "_" << count <<
             " (.a("<< first_operand<<"),.b(" << second_operand
           <<"),.prod("<< operation.result <<"));";
    } 

    else if (operation.opType == "INC" || operation.opType == "DEC") { 
        int nonOneOperandIndex = isExactlyOne(operation.operands[0]) ? 1 : 0;
        std::string selectedOperand = nonOneOperandIndex == 0 ? first_operand : second_operand;
        ss << moduleName << " # (.DATAWIDTH("<< operation.width <<")) " << operation.opType << "_" << count <<
             " (.a("<< selectedOperand<<"),.d("<< operation.result <<"));";
    }
    else if (operation.opType == "SHR" || operation.opType == "SHL") {
        ss << moduleName << " # (.DATAWIDTH(" << operation.width << ")) " << operation.opType << "_" << count <<
            " (.a(" << first_operand << "),.sh_amt(";

        // Find the corresponding component of the second operand
        auto operandComponent = std::find_if(components.begin(), components.end(), [&](const Component& comp) { return comp.name == operation.operands[1]; });

        // Check if the component is found and if it's signed
        if (operandComponent != components.end() && operandComponent->isSigned) {
            // Operand is signed, use $unsigned to convert it
            ss << "$unsigned(" << second_operand << ")";
        } else {
            // Operand is unsigned or not found, use it directly
            ss << second_operand;
        }
        //std::cout << "SH DEBUG" << second_operand <<std::endl;
        ss << "),.d(" << operation.result << "));";
    }

    else if (operation.opType == "DIV") { 
        ss << moduleName << " # (.DATAWIDTH("<< operation.width <<")) " << operation.opType << "_" << count <<
             " (.a("<<first_operand<<"),.b(" << second_operand
           <<"),.quot("<< operation.result <<"));";
    } 
    else if (operation.opType == "MOD") { 
        ss << moduleName << " # (.DATAWIDTH("<< operation.width <<")) " << operation.opType << "_" << count <<
             " (.a("<< first_operand<<"),.b(" << second_operand 
           <<"),.rem("<< operation.result <<"));";
    }
    else if (operation.opType == "MUX2x1") { 
        ss << moduleName << " # (.DATAWIDTH("<< operation.width <<")) " << operation.opType << "_" << count <<
             " (.sel("<< first_operand<<"),.b(" <<second_operand 
           <<"),.d("<< operation.result <<"),.a("<< third_operand<<"));";
    }
    else if (operation.opType == "COMP") { 
        if(operation.symbol == "=="){
					ss << moduleName << " # (.DATAWIDTH("<< operation.width <<")) " << operation.opType << "_" << count <<
							" (.a("<< first_operand<<"),.b(" <<second_operand
					<<"),.eq("<< operation.result <<"),.lt(0),.gt(0));";
        }
	      else if(operation.symbol == ">"){
					ss << moduleName << " # (.DATAWIDTH("<< operation.width <<")) " << operation.opType << "_" << count <<
							" (.a("<< first_operand<<"),.b(" << second_operand 
					<<"),.eq(0),.lt(0),.gt("<< operation.result <<"));";
        }
	      else if(operation.symbol == "<"){
					ss << moduleName << " # (.DATAWIDTH("<< operation.width <<")) " << operation.opType << "_" << count <<
							" (.a("<< first_operand<<"),.b(" << second_operand 
					<<"),.eq(0),.lt("<< operation.result <<"),.gt(0));";
        }									   
    }

    // Add instantiation code for more operation types as needed
    return ss.str();
}