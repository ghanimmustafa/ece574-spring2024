#include "VerilogGenerator.h"
#include <fstream>
#include <sstream>
#include <algorithm> // For std::remove_if
#include <cctype> // For std::isspace
#include <chrono>
#include <ctime>
#include <iostream>

// Constructor definition
bool isExactlyOne(const std::string& str);  




VerilogGenerator::VerilogGenerator(const std::vector<Component>& components, const std::vector<Operation>& operations)
    : components(components), operations(operations) {}

void VerilogGenerator::generateVerilog(const std::string& outputPath, const std::string& moduleName) {
    std::ofstream outFile(outputPath);
    std::stringstream moduleDecl, wires;
    auto now = std::chrono::system_clock::now();
    std::time_t currentTime = std::chrono::system_clock::to_time_t(now);

    // Write system log info
    moduleDecl << "// Generated by University of Arizona - ECE 574 - HLS Tool\n"
            << "// Authors: Mustafa Ghanim and Umut Suluhan\n"
            << "// Date and Time: " << std::ctime(&currentTime)  << "\n"; // ctime includes a newline at the end
    // Start module declaration
    moduleDecl <<"`timescale 1ns / 1ps\n" << "module " << moduleName << "(\n";
    moduleDecl << "\tinput Clk, Rst,\n"; 

    // Process components to generate module IOs and wires
    for (const auto& component : components) {
        std::string signModifier = component.isSigned ? " signed" : "";
        std::string widthSpecifier = (component.width > 1) ? " [" + std::to_string(component.width - 1) + ":0]" : "";
        
        if (component.type == "input") {
            moduleDecl << "\tinput" << signModifier << widthSpecifier << " " << component.name << ",\n";
        } else if (component.type == "output") {
            moduleDecl << "\toutput" << signModifier << widthSpecifier << " " << component.name << ",\n";
        } else if (component.type == "wire" || component.type == "register") {
            wires << "wire" << signModifier << widthSpecifier << " " << component.name << ";\n";
        }
    }


    // Remove the last comma and add closing parenthesis
    std::string moduleDeclStr = moduleDecl.str();
    moduleDeclStr = moduleDeclStr.substr(0, moduleDeclStr.rfind(',')) + "\n);";
    
    outFile << moduleDeclStr << "\n" << wires.str() << "\n";

    // Generate and write code for each operation
    for (const auto& operation : operations) {
        outFile << generateOperationCode(operation) << std::endl;
    }

    outFile << "endmodule\n";
}

std::string VerilogGenerator::generateComponentCode(const Component& component) const {
    std::stringstream ss;
    // Example: Generating Verilog for a wire
    if (component.type == "wire") {
        ss << "wire [" << (component.width - 1) << ":0] " << component.name << ";";
    }
    // Add more conditions for inputs/outputs if needed
    return ss.str();
}

std::string VerilogGenerator::generateOperationCode(const Operation& operation) const {
    std::stringstream ss;
    static std::unordered_map<std::string, int> opCounters;
    int count = ++opCounters[operation.opType];
    std::string moduleName = operation.isSigned ? "S" + operation.opType : operation.opType;
    // Function to determine the required padding or extension for operands
    auto bit_extensions = [&](const std::string& operand) {
        for (const auto& comp : components) {
            if (comp.name == operand) {
                // Check if the operand is signed
                bool isSignedOperand = comp.isSigned;
                bool isSignedOperation = operation.isSigned;
                // Get the width of the operand
                int operandWidth = comp.width;
                // Determine the required padding or extension
                int requiredWidth = operation.width; // Width of the result
                if (operation.opType == "MUX2x1" && operand == operation.operands[0] && operandWidth >= 1) {
                // For MUX2x1 operation, modify the third operand to take only its LSB
                    if(operandWidth > 1 ) return operand + "[0]";
                    else  return operand;
                  
                }               
                if (operandWidth < requiredWidth) {
                    if (isSignedOperand) {
                        // Sign extension
                        return "{{" + std::to_string(requiredWidth - operandWidth) + "{" + operand + "[" + std::to_string(operandWidth - 1) + "]}}, " + operand + "}";
                    } else {
                        // Zero padding
                        return "{{" + std::to_string(requiredWidth - operandWidth) + "{1'b0}}, " + operand + "}";
                    }
                } else if (operandWidth > requiredWidth) {
                    // Extract least significant bits if operand width is greater
                    return operand + "[" + std::to_string(requiredWidth - 1) + ":0]";
                }
            }
        }
        // Return original operand if not found in components
        return operand;
    };
    auto bit_extension_and_sign_check = [&](const std::string& operand,int index) {
        std::string extended_operand = operand;
        for (const auto& comp : components) {
            if (comp.name == operand) {
                // Check if the operand is signed
                bool isSignedOperand = comp.isSigned;
                // Check if the operation is signed
                bool isSignedOperation = operation.isSigned;

                // Determine the required padding or extension
                int operandWidth = comp.width;
                int requiredWidth = operation.width; // Width of the result

                // Perform bit extension or truncation
                if (operandWidth < requiredWidth) {
                    if (isSignedOperand) {
                        // Sign extension
                        extended_operand = "{{" + std::to_string(requiredWidth - operandWidth) + "{" + operand + "[" + std::to_string(operandWidth - 1) + "]}}, " + operand + "}";
                    } else {
                        // Zero padding
                        extended_operand = "{{" + std::to_string(requiredWidth - operandWidth) + "{1'b0}}, " + operand + "}";
                    }
                } else if (operandWidth > requiredWidth) {
                    // Extract least significant bits if operand width is greater
                    extended_operand += "[" + std::to_string(requiredWidth - 1) + ":0]";
                }

                // Handle sign conversion
                if (isSignedOperand != isSignedOperation) {
                    // Debug: Print component and operation information
                    #if defined(ENABLE_LOGGING)  
                    std::cout << "Debug: Component found: " << comp.name << ", isSigned: " << (comp.isSigned ? "true" : "false") << ", width: " << comp.width << std::endl;
                    std::cout << "Debug: Operation sign: " << (isSignedOperation ? "signed" : "unsigned") << ", width: " << operation.width << std::endl;
                    #endif 
                    // Operand sign and operation sign are different
                    if (isSignedOperation) {
                        // Add $signed(operand)
                        if((operation.opType != "SHR" || operation.opType != "SHL") && index !=2)
                            extended_operand = "$signed(" + extended_operand + ")";
                    } else {
                        // Add $unsigned(operand)
                        extended_operand = "$unsigned(" + extended_operand + ")";
                    }
                }

                // For MUX2x1 operation, modify the third operand to take only its LSB
                if (operation.opType == "MUX2x1" && operand == operation.operands[0] && operandWidth >= 1) {
                    if (operandWidth > 1) {
                        extended_operand += "[0]";
                    }
                }

                return extended_operand;
            }
        }

        // Return original operand if not found in components
        return operand;
    };





    auto operand_sign_check = [&](const std::string& operand) {
        for (const auto& comp : components) {
            if (comp.name == operand) {
                // Check if the operand is signed
                bool isSignedOperand = comp.isSigned;
                // Check if the operation is signed
                bool isSignedOperation = operation.isSigned;
                
                if (isSignedOperand != isSignedOperation) {
                    // Operand sign and operation sign are different
                    if (isSignedOperation) {
                        // Add $signed(operand)
                        return "$signed(" + operand + ")";
                    } else {
                        // Add $unsigned(operand)
                        return "$unsigned(" + operand + ")";
                    }
                } else {
                    // Operand sign matches operation sign
                    return operand;
                }
            }
        }
        // Return original operand if not found in components
        return operand;
    };   
    std::string first_operand, second_operand, third_operand;
     // In-place modification of operands
    // Modify operands based on availability
    int index;
    if (operation.operands.size() > 0) {
        index = 1;
        first_operand = bit_extension_and_sign_check(operation.operands[0],index);

    }
    if (operation.operands.size() > 1) {
        index = 2;
        second_operand = bit_extension_and_sign_check(operation.operands[1],index);

    }
    if (operation.operands.size() > 2) {
        index = 3;
        third_operand = bit_extension_and_sign_check(operation.operands[2],index);
    }
   // std::string second_operand = getModifiedOperand(operation.operands[1]);
    // Choose the submodule name based on signedness
  // Preprocess operands
    if (operation.opType == "REG") { // Assuming "+" denotes ADD operation
        // Example instantiation of an ADD datapath component
        ss << "REG" << " # (.DATAWIDTH("<< operation.width <<")) " << operation.opType << "_" << count <<
             " (.d("<< first_operand<<"),.Clk(Clk),.Rst(Rst),.q("<< operation.result <<"));";
    }    
    if (operation.opType == "ADD") { // Assuming "+" denotes ADD operation
        // Example instantiation of an ADD datapath component
        ss << moduleName << " # (.DATAWIDTH("<< operation.width <<")) " << operation.opType << "_" << count <<
             " (.a("<< first_operand <<"),.b(" << second_operand
           <<"),.sum("<< operation.result <<"));";
    }
    else if (operation.opType == "SUB") { 
        ss << moduleName << " # (.DATAWIDTH("<< operation.width <<")) " << operation.opType << "_" << count <<
             " (.a("<< first_operand<<"),.b(" << second_operand
           <<"),.diff("<< operation.result <<"));";
    }

    else if (operation.opType == "MUL") { 
        ss << moduleName << " # (.DATAWIDTH("<< operation.width <<")) " << operation.opType << "_" << count <<
             " (.a("<< first_operand<<"),.b(" << second_operand
           <<"),.prod("<< operation.result <<"));";
    } 

    else if (operation.opType == "INC" || operation.opType == "DEC") { 
        int nonOneOperandIndex = isExactlyOne(operation.operands[0]) ? 1 : 0;
        std::string selectedOperand = nonOneOperandIndex == 0 ? first_operand : second_operand;
        ss << moduleName << " # (.DATAWIDTH("<< operation.width <<")) " << operation.opType << "_" << count <<
             " (.a("<< selectedOperand<<"),.d("<< operation.result <<"));";
    }
    else if (operation.opType == "SHR" || operation.opType == "SHL") {
        ss << moduleName << " # (.DATAWIDTH(" << operation.width << ")) " << operation.opType << "_" << count <<
            " (.a(" << first_operand << "),.sh_amt(";

        // Find the corresponding component of the second operand
        auto operandComponent = std::find_if(components.begin(), components.end(), [&](const Component& comp) { return comp.name == operation.operands[1]; });

        // Check if the component is found and if it's signed
        if (operandComponent != components.end() && operandComponent->isSigned) {
            // Operand is signed, use $unsigned to convert it
            ss << "$unsigned(" << second_operand << ")";
        } else {
            // Operand is unsigned or not found, use it directly
            ss << second_operand;
        }
        ss << second_operand;
        ss << "),.d(" << operation.result << "));";
    }

    else if (operation.opType == "DIV") { 
        ss << moduleName << " # (.DATAWIDTH("<< operation.width <<")) " << operation.opType << "_" << count <<
             " (.a("<<first_operand<<"),.b(" << second_operand
           <<"),.quot("<< operation.result <<"));";
    } 
    else if (operation.opType == "MOD") { 
        ss << moduleName << " # (.DATAWIDTH("<< operation.width <<")) " << operation.opType << "_" << count <<
             " (.a("<< first_operand<<"),.b(" << second_operand 
           <<"),.rem("<< operation.result <<"));";
    }
    else if (operation.opType == "MUX2x1") { 
        ss << moduleName << " # (.DATAWIDTH("<< operation.width <<")) " << operation.opType << "_" << count <<
             " (.sel("<< first_operand<<"),.b(" <<second_operand 
           <<"),.d("<< operation.result <<"),.a("<< third_operand<<"));";
    }
    else if (operation.opType == "COMP") { 
        if(operation.symbol == "=="){
					ss << moduleName << " # (.DATAWIDTH("<< operation.width <<")) " << operation.opType << "_" << count <<
							" (.a("<< first_operand<<"),.b(" <<second_operand
					<<"),.eq("<< operation.result <<"),.lt(0),.gt(0));";
        }
	      else if(operation.symbol == ">"){
					ss << moduleName << " # (.DATAWIDTH("<< operation.width <<")) " << operation.opType << "_" << count <<
							" (.a("<< first_operand<<"),.b(" << second_operand 
					<<"),.eq(0),.lt(0),.gt("<< operation.result <<"));";
        }
	      else if(operation.symbol == "<"){
					ss << moduleName << " # (.DATAWIDTH("<< operation.width <<")) " << operation.opType << "_" << count <<
							" (.a("<< first_operand<<"),.b(" << second_operand 
					<<"),.eq(0),.lt("<< operation.result <<"),.gt(0));";
        }									   
    }

    // Add instantiation code for more operation types as needed
    return ss.str();
}

