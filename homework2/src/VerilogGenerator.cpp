#include "VerilogGenerator.h"
#include <fstream>
#include <sstream>
#include <algorithm> // For std::remove_if
#include <cctype> // For std::isspace
#include <chrono>
#include <ctime>

// Constructor definition
bool isExactlyOne(const std::string& str);  

VerilogGenerator::VerilogGenerator(const std::vector<Component>& components, const std::vector<Operation>& operations)
    : components(components), operations(operations) {}

void VerilogGenerator::generateVerilog(const std::string& outputPath, const std::string& moduleName) {
    std::ofstream outFile(outputPath);
    std::stringstream moduleDecl, wires;
    auto now = std::chrono::system_clock::now();
    std::time_t currentTime = std::chrono::system_clock::to_time_t(now);

    // Write system log info
    moduleDecl << "// Generated by University of Arizona - ECE 574 - HLS Tool\n"
            << "// Authors: Mustafa Ghanim and Umut Suluhan\n"
            << "// Date and Time: " << std::ctime(&currentTime)  << "\n"; // ctime includes a newline at the end
    // Start module declaration
    moduleDecl <<"`timescale 1ns / 1ps\n" << "module " << moduleName << "(\n";
    moduleDecl << "\tinput Clk, Rst;\n"; 

    // Process components to generate module IOs and wires
    for (const auto& component : components) {
        std::string signModifier = component.isSigned ? " signed" : "";
        std::string widthSpecifier = (component.width > 1) ? " [" + std::to_string(component.width - 1) + ":0]" : "";
        
        if (component.type == "input") {
            moduleDecl << "\tinput" << signModifier << widthSpecifier << " " << component.name << ",\n";
        } else if (component.type == "output") {
            moduleDecl << "\toutput" << signModifier << widthSpecifier << " " << component.name << ",\n";
        } else if (component.type == "wire" || component.type == "register") {
            wires << "wire" << signModifier << widthSpecifier << " " << component.name << ";\n";
        }
    }


    // Remove the last comma and add closing parenthesis
    std::string moduleDeclStr = moduleDecl.str();
    moduleDeclStr = moduleDeclStr.substr(0, moduleDeclStr.rfind(',')) + "\n);";
    
    outFile << moduleDeclStr << "\n" << wires.str() << "\n";

    // Generate and write code for each operation
    for (const auto& operation : operations) {
        outFile << generateOperationCode(operation) << std::endl;
    }

    outFile << "endmodule\n";
}

std::string VerilogGenerator::generateComponentCode(const Component& component) const {
    std::stringstream ss;
    // Example: Generating Verilog for a wire
    if (component.type == "wire") {
        ss << "wire [" << (component.width - 1) << ":0] " << component.name << ";";
    }
    // Add more conditions for inputs/outputs if needed
    return ss.str();
}

std::string VerilogGenerator::generateOperationCode(const Operation& operation) const {
    std::stringstream ss;
    static std::unordered_map<std::string, int> opCounters;
    int count = ++opCounters[operation.opType];
    std::string moduleName = operation.isSigned ? "S" + operation.opType : operation.opType;
    // Choose the submodule name based on signedness
    if (operation.opType == "REG") { // Assuming "+" denotes ADD operation
        // Example instantiation of an ADD datapath component
        ss << "REG" << " # (.DATAWIDTH("<< operation.width <<")) " << operation.opType << "_" << count <<
             " (.d("<< operation.operands[0]<<"),.Clk(Clk),.Rst(Rst),.q("<< operation.result <<"));";
    }    
    if (operation.opType == "ADD") { // Assuming "+" denotes ADD operation
        // Example instantiation of an ADD datapath component
        ss << moduleName << " # (.DATAWIDTH("<< operation.width <<")) " << operation.opType << "_" << count <<
             " (.a("<< operation.operands[0]<<"),.b(" << operation.operands[1] 
           <<"),.sum("<< operation.result <<"));";
    }
    else if (operation.opType == "SUB") { 
        ss << moduleName << " # (.DATAWIDTH("<< operation.width <<")) " << operation.opType << "_" << count <<
             " (.a("<< operation.operands[0]<<"),.b(" << operation.operands[1] 
           <<"),.diff("<< operation.result <<"));";
    }

    else if (operation.opType == "MUL") { 
        ss << moduleName << " # (.DATAWIDTH("<< operation.width <<")) " << operation.opType << "_" << count <<
             " (.a("<< operation.operands[0]<<"),.b(" << operation.operands[1] 
           <<"),.prod("<< operation.result <<"));";
    } 

    else if (operation.opType == "INC" || operation.opType == "DEC") { 
        int nonOneOperandIndex = isExactlyOne(operation.operands[0]) ? 1 : 0;
        ss << moduleName << " # (.DATAWIDTH("<< operation.width <<")) " << operation.opType << "_" << count <<
             " (.a("<< operation.operands[nonOneOperandIndex]<<"),.d("<< operation.result <<"));";
    }
    else if (operation.opType == "SHR" || operation.opType == "SHL") {
        ss << moduleName << " # (.DATAWIDTH(" << operation.width << ")) " << operation.opType << "_" << count <<
            " (.a(" << operation.operands[0] << "),.sh_amt(";

        // Find the corresponding component of the second operand
        auto operandComponent = std::find_if(components.begin(), components.end(), [&](const Component& comp) { return comp.name == operation.operands[1]; });

        // Check if the component is found and if it's signed
        if (operandComponent != components.end() && operandComponent->isSigned) {
            // Operand is signed, use $unsigned to convert it
            ss << "$unsigned(" << operation.operands[1] << ")";
        } else {
            // Operand is unsigned or not found, use it directly
            ss << operation.operands[1];
        }

        ss << "),.d(" << operation.result << "));";
    }

    else if (operation.opType == "DIV") { 
        ss << moduleName << " # (.DATAWIDTH("<< operation.width <<")) " << operation.opType << "_" << count <<
             " (.a("<< operation.operands[0]<<"),.b(" << operation.operands[1] 
           <<"),.quot("<< operation.result <<"));";
    } 
    else if (operation.opType == "MOD") { 
        ss << moduleName << " # (.DATAWIDTH("<< operation.width <<")) " << operation.opType << "_" << count <<
             " (.a("<< operation.operands[0]<<"),.b(" << operation.operands[1] 
           <<"),.rem("<< operation.result <<"));";
    }
    else if (operation.opType == "MUX2x1") { 
        ss << moduleName << " # (.DATAWIDTH("<< operation.width <<")) " << operation.opType << "_" << count <<
             " (.sel("<< operation.operands[0]<<"),.b(" << operation.operands[1] 
           <<"),.d("<< operation.result <<"),.a("<<  operation.operands[2]<<"));";
    }
    else if (operation.opType == "COMP") { 
        if(operation.symbol == "=="){
					ss << moduleName << " # (.DATAWIDTH("<< operation.width <<")) " << operation.opType << "_" << count <<
							" (.a("<< operation.operands[0]<<"),.b(" << operation.operands[1] 
					<<"),.eq("<< operation.result <<"),.lt(0),.gt(0));";
        }
	      else if(operation.symbol == ">"){
					ss << moduleName << " # (.DATAWIDTH("<< operation.width <<")) " << operation.opType << "_" << count <<
							" (.a("<< operation.operands[0]<<"),.b(" << operation.operands[1] 
					<<"),.eq(0),.lt(0),.gt("<< operation.result <<"));";
        }
	      else if(operation.symbol == "<"){
					ss << moduleName << " # (.DATAWIDTH("<< operation.width <<")) " << operation.opType << "_" << count <<
							" (.a("<< operation.operands[0]<<"),.b(" << operation.operands[1] 
					<<"),.eq(0),.lt("<< operation.result <<"),.gt(0));";
        }									   
    }

    // Add instantiation code for more operation types as needed
    return ss.str();
}

